module Gui
    ( addFatAction2
    , okReadAction
    ) where

import Control.Monad
import Control.Monad.IO.Class
import Control.Monad.Trans.Maybe
import Control.Monad.Trans.State --use Lazy?
-- import Data.IORef
-- import System.Glib.UTFString.GLibString --required for type of fatEntryRow2
                                           --otherwise no haddock for this?
import Graphics.UI.Gtk hiding (Action, backspace)

-- |Run the graphical user interface to input the fat information
runGui :: IO()
runGui = undefined

-------------------------data entry field construction--------------------
-- | a rewrite of boxPackStart for chaining
boxPacker
  :: (BoxClass b, WidgetClass child) =>
     Packing -> Int -> b -> child -> IO b
boxPacker packType pad bx elem = boxPackStart bx elem packType pad >> return bx

-- |Add a new entry for fat input and display it.
-- A fat entry field is a 2-row vbox consisting of a row for the fat type
-- and one for the fat amount
addFatAction2 :: Builder -> IO()
addFatAction2 build =
  builderGetObject build castToBox "entryBoxContainer" >>= packEntry >>= showAll
  where
    packEntry b = newFatEntry2 >>= boxPacker PackNatural 5 b
    showAll b = widgetShowAll b
    
-- |Pack rows for fat-type and amount into the entry box
newFatEntry2 :: IO VBox
newFatEntry2 =
  vBoxNew False 0 >>= packTypeRow >>= packAmountRow
  where 
    packTypeRow vb = fatEntryRow2 "Fat type" addDeleteButton2 >>= packNatural vb
    packAmountRow vb = fatEntryRow2 "Amount" (return . id) >>= packNatural vb
    packNatural = boxPacker PackNatural 0 

 {-|Pack a label with text labtext, an entry field and a delete button
   with action delButton into a row for the fat-entry. The idea is to have
   a delete button in the amount row generated by @delButton=addDeleteButton@
   for deleting the whole entry and no button in the amount row using
   @delButton=return . id@. See the usage in @packTypeRow@ and @packAmountRow@
   in @newFatEntry2@
 -}
--fatEntryRow2 :: System.Glib.UTFString.GlibString string =>
                --string -> (HBox -> IO b) -> IO b   
fatEntryRow2 labtxt delButton =
  hBoxNew False 0 >>= packLabel >>= packEntry >>= delButton
     where
       packLabel = \b -> labelNew (Just labtxt) >>= boxPackerLocalNat b
       packEntry = \b -> entryNew >>= boxPackerLocalGrow b
       boxPackerLocalNat  = boxPacker PackNatural 10
       boxPackerLocalGrow  = boxPacker PackGrow 0
-- |Pack a button with label in the given and connect an action that removes
-- the fat entry from the entry containers
-- addDeleteButton2 :: BoxClass b => b -> IO b
addDeleteButton2 hb =
  buttonNewWithLabel "-" >>= packer hb >>= onActivation hb >> return hb
    where
      -- ^Note: boxPacker can't be used here as
      -- > packer = boxPacker PackNatural 0
      -- it returns the wrong type, namely @hb@ rather than @elem@
      packer hb = \elem -> boxPackStart hb elem PackNatural 0 >> return elem
      onActivation hpar = \button -> on button buttonActivated (rmAction hpar)
      -- rmAction :: GObjectClass a => a -> IO ()
      rmAction h = do
        Just ctent <- widgetGetParent (castToWidget h)
        Just con <- widgetGetParent ctent
        containerRemove (castToContainer con) ctent
-------------------------------data extraction---------------------------------
-- |State transition function for creating StateT monad to pass string as
-- state and list of row-boxes as values in a StateT String IO monad
stateFunc :: GObjectClass a => [a] -> [Char] -> IO ([a], [Char])
stateFunc (b:r) s|s=="" = getText b >>= \str -> return (r,"--fatspec " ++ str)
             |otherwise = getText b >>= \str -> return (r,s ++ ":" ++ str)
             where getText c= containerGetChildren (castToContainer c) >>= etext
                   etext (_:etrt:_) = entryGetText $ castToEntry etrt
                   etext _ = error "etext not receiving proper row"
stateFunc [] s = return ([],s) -- TODO: think about this
-- |Extracting fat information from the fat entry, which consists of
-- two vboxes representing the fat-type and fat-amount rows, respectively,
-- which in turn consist of subwidgets, the second one being the text entry
-- field of interest. This is actually used as getFatInfoM :: VBox -> IO String.
getFatInfoM :: ContainerClass self => self -> IO [Char]
getFatInfoM b = containerGetChildren b >>= \cl -> execStateT (extractor cl >>= extractor) ""
  where extractor  = StateT . stateFunc

-- |action for ok-button: read the contents of the fat-entry children
-- Note: these should be fed into an option-checker rather than a mere
-- putStrLn . show, with a complaint-dialog if things go wrong
okReadAction :: Builder -> IO ()
okReadAction b = do
  entries <-builderGetObject b castToContainer "entryBoxContainer"
  containerGetChildren entries >>= foldM foldFatInfo "" >>= (putStrLn . show)
  return ()

-- |Function to foldM an IO [Children] to concatenate the IO String results
-- from getFatInfo. Since containerGetChildren returns widgets, they have
-- to be cast back to containers in order to extract their children in return.
foldFatInfo str box = getFatInfoM (castToContainer box) >>= \nstr -> return (str++" "++nstr)
